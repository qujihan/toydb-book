#import "../lib.typ":*
= 介绍<介绍>

SQL是一个用于查询关系型数据的高级声明式语言。它已经成为了关系数据查询的事实标准，并且被大部分的关系型数据库所支持。此外，在一些大数据系统中也逐渐开始流行。

SQL允许对关系型数据进行声明式的查询，包括选择、连接、分组、聚合以及嵌套子查询，这对各种决策的支持非常重要，尤其是企业中的商业智能场景。

以下面的@query1\为例：

#sql-code()[
```sql
SELECT *
FROM R, S, T
WHERE R.a = S.a AND S.c = T.d AND T.e = 10
```
]<query1>

在 @查询处理流程 中展示了在一个数据库管理系统中，处理一个Query的SQL的主要流程。Query处理的三个流程将会在下面依次介绍。

#picture-figure("查询处理流程", image("../pic/查询处理流程.png"))<查询处理流程>

*解析以及验证（Parsing and Validation）* 解析与验证这一步是将一个SQL查询转换成内部的表现形式，这一步确保查询符合SQL的语法规则并且引用了已经存在的数据库的对象，例如：表或者列等。这一步的输出结果为逻辑查询树，逻辑查询树是一个使用代数表示的Query，其中每一个树的节点是一个关系算子（例如：Select、Join等）。在
@查询处理流程 展示了@query1\在经过解析以及验证后的输出的逻辑查询树。

*查询优化（Query optimizer）* _查询优化（query optimizer）_将逻辑查询树作为输入，并负责生成由查询执行引擎解释或者编译的_高效的_执行计划。_执行计划（execution
plan）_（也被成为_计划（plan）_）是一个由物理算子所组成的树，树的边表示为两个操作之间的数据流动。例如在@查询处理流程\中展示了@query1\在经过查询优化后输出的执行计划。对于一个给定的查询来说，生成的执行计划的数量可能会随着引用的表的数量而呈现指数增长的趋势。并且不同的执行计划会有着不同的执行效率。因此，查询的性能很大程度上取决于优化器是否能从大量的执行计划中选择出一个效率高的执行计划的能力。有关关系型数据库的查询优化的概述，可以参考@An-overview-of-query-optimization-in-relational-systems。

*查询执行（Query execution）* 查询执行引擎从查询优化中获取执行的计划，然后生成查询的结果。查询执行引擎实现了一系列的_物理算子_，物理算子负责为查询计划构建数据块。一个物理算子将一个或者多个数据记录作为其输入，称之为_行（rows）_，并输出一组行。常见的物理算子包括`Table Scan`、`Index Scan`、`Index Seek`（详见
@附录 ）、`Hash Join`、`Nested Loops Join`、`Merge Join`、`Sort`等。有关各种物理算子算法的描述，建议参考@Query-evaluation-techniques-for-large-databases。

大多数关系型数据库中，执行引擎都使用迭代器模型，这个模型的每一个物理算子都实现`Open`、`GetNext`、`Close`这三个方法。每一个迭代器都包含了记录其状态（包括大小、哈希表的位置等信息）。在`Open`中，算子初始化并且开始准备处理数据。当`GetNext`被调用的时候，算子会生成下一个输出的行，或者返回没有行（没有结果，意味着处理的结束）。这不难想到，要生成输出的行，执行计划中的非叶节点必须要多次对其子算子调用`GetNext`。例如在@查询处理流程\中，`Nested Loop Join`算子在`Hash Join`算子上调用`GetNext`，而`Hash Join`算子又调用了`Table Scan`的`GetNext`方法。当一个算子完成了输出（也就是没有更多的行了），父算子会对其调用`Close`方法，允许其清理状态信息。上述迭代器模型可以方便的添加新的算子，由于每一个运算符都是一个迭代器，对数据执行的是“拉”取操作。所以也被成为_拉取模型（pull
module）_。这里建议通过阅读/*TODO*/来了解更多的关于执行引擎中_pull module_的相关知识。

== 查询优化的关键挑战
== System R 查询优化器
== 需要可扩展的查询优化器架构
== 大纲
== 建议阅读